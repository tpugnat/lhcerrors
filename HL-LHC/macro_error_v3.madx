! Newest error macros, for HL-LHC 1.3 optics and higher
if ( ver_hllhc_optics < 1.3) {
  print, text="Fatal error: macro_error_v3 is only compatible with HL-LHC v1.3 optics or higher.";
  stop;
};
!-------------------------------HISTORY-----------------------------------------
!! S. Fartoukh Feb. 2009: macros for error generation in the new D1/IT
!  bug corrected in reset_MQX_corr 12/05/2009 (the IT correction was always on)
!! S. Fartoukh March 2012 update the error assignement routine for an arbitrary ref radius (defined in the error table) 
!  and the resetIT corrector routine for new IT correctors
!! T. Pugnat Sep. 2022: new macros for error generation in HL-LHC magnets using
!  external table for magnets orientation.
!! T. Pugnat Sep. 2024: Now macro can generate uniform error for HL-LHC magnets.
!-------------------------------------------------------------------------------


magnetic_sign=1;


ON_ALL_MULT: macro = {
  ON_A1s =  1 ; ON_A1r =  1 ; ON_B1s =  1 ; ON_B1r =  1;
  ON_A2s =  1 ; ON_A2r =  1 ; ON_B2s =  1 ; ON_B2r =  1;
  ON_A3s =  1 ; ON_A3r =  1 ; ON_B3s =  1 ; ON_B3r =  1;
  ON_A4s =  1 ; ON_A4r =  1 ; ON_B4s =  1 ; ON_B4r =  1;
  ON_A5s =  1 ; ON_A5r =  1 ; ON_B5s =  1 ; ON_B5r =  1;
  ON_A6s =  1 ; ON_A6r =  1 ; ON_B6s =  1 ; ON_B6r =  1;
  ON_A7s =  1 ; ON_A7r =  1 ; ON_B7s =  1 ; ON_B7r =  1;
  ON_A8s =  1 ; ON_A8r =  1 ; ON_B8s =  1 ; ON_B8r =  1;
  ON_A9s =  1 ; ON_A9r =  1 ; ON_B9s =  1 ; ON_B9r =  1;
  ON_A10s =  1; ON_A10r =  1; ON_B10s =  1; ON_B10r =  1;
  ON_A11s =  1; ON_A11r =  1; ON_B11s =  1; ON_B11r =  1;
  ON_A12s =  1; ON_A12r =  1; ON_B12s =  1; ON_B12r =  1;
  ON_A13s =  1; ON_A13r =  1; ON_B13s =  1; ON_B13r =  1;
  ON_A14s =  1; ON_A14r =  1; ON_B14s =  1; ON_B14r =  1;
  ON_A15s =  1; ON_A15r =  1; ON_B15s =  1; ON_B15r =  1;
};


define_uncertainty_mult(typm,nrj) : macro ={
  b1ss_U  =  b1U_typm_nrj  * TGAUSS(1.5) / 1.5; a1ss_U  =  a1U_typm_nrj  * TGAUSS(1.5) / 1.5;
  b2ss_U  =  b2U_typm_nrj  * TGAUSS(1.5) / 1.5; a2ss_U  =  a2U_typm_nrj  * TGAUSS(1.5) / 1.5;
  b3ss_U  =  b3U_typm_nrj  * TGAUSS(1.5) / 1.5; a3ss_U  =  a3U_typm_nrj  * TGAUSS(1.5) / 1.5;
  b4ss_U  =  b4U_typm_nrj  * TGAUSS(1.5) / 1.5; a4ss_U  =  a4U_typm_nrj  * TGAUSS(1.5) / 1.5;
  b5ss_U  =  b5U_typm_nrj  * TGAUSS(1.5) / 1.5; a5ss_U  =  a5U_typm_nrj  * TGAUSS(1.5) / 1.5;
  b6ss_U  =  b6U_typm_nrj  * TGAUSS(1.5) / 1.5; a6ss_U  =  a6U_typm_nrj  * TGAUSS(1.5) / 1.5;
  b7ss_U  =  b7U_typm_nrj  * TGAUSS(1.5) / 1.5; a7ss_U  =  a7U_typm_nrj  * TGAUSS(1.5) / 1.5;
  b8ss_U  =  b8U_typm_nrj  * TGAUSS(1.5) / 1.5; a8ss_U  =  a8U_typm_nrj  * TGAUSS(1.5) / 1.5;
  b9ss_U  =  b9U_typm_nrj  * TGAUSS(1.5) / 1.5; a9ss_U  =  a9U_typm_nrj  * TGAUSS(1.5) / 1.5;
  b10ss_U =  b10U_typm_nrj * TGAUSS(1.5) / 1.5; a10ss_U =  a10U_typm_nrj * TGAUSS(1.5) / 1.5;
  b11ss_U =  b11U_typm_nrj * TGAUSS(1.5) / 1.5; a11ss_U =  a11U_typm_nrj * TGAUSS(1.5) / 1.5;
  b12ss_U =  b12U_typm_nrj * TGAUSS(1.5) / 1.5; a12ss_U =  a12U_typm_nrj * TGAUSS(1.5) / 1.5;
  b13ss_U =  b13U_typm_nrj * TGAUSS(1.5) / 1.5; a13ss_U =  a13U_typm_nrj * TGAUSS(1.5) / 1.5;
  b14ss_U =  b14U_typm_nrj * TGAUSS(1.5) / 1.5; a14ss_U =  a14U_typm_nrj * TGAUSS(1.5) / 1.5;
  b15ss_U =  b15U_typm_nrj * TGAUSS(1.5) / 1.5; a15ss_U =  a15U_typm_nrj * TGAUSS(1.5) / 1.5;
};


  !Define the uncertainty for a given magnet type typm and/or aperture
define_uncertainty(typm) : macro ={
  if (NRJ<4999.99){exec,define_uncertainty_mult(typm,inj);};
  if (NRJ>4999.99){exec,define_uncertainty_mult(typm,col);};
};


new_magnetfamily_mult(typm,nrj) : macro ={
  if (use_uniform_error_distribution==1){
    b1ss  = 0.000; a1ss  = 0.000;
    b2ss  = 0.000; a2ss  = 0.000;
    b3ss  = 0.000; a3ss  = 0.000;
    b4ss  = 0.000; a4ss  = 0.000;
    b5ss  = 0.000; a5ss  = 0.000;
    b6ss  = 0.000; a6ss  = 0.000;
    b7ss  = 0.000; a7ss  = 0.000;
    b8ss  = 0.000; a8ss  = 0.000;
    b9ss  = 0.000; a9ss  = 0.000;
    b10ss = 0.000; a10ss = 0.000;
    b11ss = 0.000; a11ss = 0.000;
    b12ss = 0.000; a12ss = 0.000;
    b13ss = 0.000; a13ss = 0.000;
    b14ss = 0.000; a14ss = 0.000;
    b15ss = 0.000; a15ss = 0.000;
  } else {
    b1ss  = b1M_typm_nrj  + b1ss_U ; a1ss  = a1M_typm_nrj  +  a1ss_U ;
    b2ss  = b2M_typm_nrj  + b2ss_U ; a2ss  = a2M_typm_nrj  +  a2ss_U ;
    b3ss  = b3M_typm_nrj  + b3ss_U ; a3ss  = a3M_typm_nrj  +  a3ss_U ;
    b4ss  = b4M_typm_nrj  + b4ss_U ; a4ss  = a4M_typm_nrj  +  a4ss_U ;
    b5ss  = b5M_typm_nrj  + b5ss_U ; a5ss  = a5M_typm_nrj  +  a5ss_U ;
    b6ss  = b6M_typm_nrj  + b6ss_U ; a6ss  = a6M_typm_nrj  +  a6ss_U ;
    b7ss  = b7M_typm_nrj  + b7ss_U ; a7ss  = a7M_typm_nrj  +  a7ss_U ;
    b8ss  = b8M_typm_nrj  + b8ss_U ; a8ss  = a8M_typm_nrj  +  a8ss_U ;
    b9ss  = b9M_typm_nrj  + b9ss_U ; a9ss  = a9M_typm_nrj  +  a9ss_U ;
    b10ss = b10M_typm_nrj + b10ss_U; a10ss = a10M_typm_nrj +  a10ss_U;
    b11ss = b11M_typm_nrj + b11ss_U; a11ss = a11M_typm_nrj +  a11ss_U;
    b12ss = b12M_typm_nrj + b12ss_U; a12ss = a12M_typm_nrj +  a12ss_U;
    b13ss = b13M_typm_nrj + b13ss_U; a13ss = a13M_typm_nrj +  a13ss_U;
    b14ss = b14M_typm_nrj + b14ss_U; a14ss = a14M_typm_nrj +  a14ss_U;
    b15ss = b15M_typm_nrj + b15ss_U; a15ss = a15M_typm_nrj +  a15ss_U;
  };
};


  !Calculate the actual average (bn,an) of a given single bore magnet family typm 
  !for a given seed and at a GIVEN NRJ given in the sample job
new_magnetfamily(typm) : macro ={
  if (print_errors==1){print,text="Magnet family: typm";};
  exec define_uncertainty(typm);
  if (NRJ<4999.99){exec,new_magnetfamily_mult(typm,inj);};
  if (NRJ>4999.99){exec,new_magnetfamily_mult(typm,col);};
};


new_magnetfamily_2in1(typm,nrj,mmmbbb,mmmqqq) : macro ={
  if (use_uniform_error_distribution==1){
    b1ss_V1  = 0.000; a1ss_V1  = 0.000;
    b2ss_V1  = 0.000; a2ss_V1  = 0.000;
    b3ss_V1  = 0.000; a3ss_V1  = 0.000;
    b4ss_V1  = 0.000; a4ss_V1  = 0.000;
    b5ss_V1  = 0.000; a5ss_V1  = 0.000;
    b6ss_V1  = 0.000; a6ss_V1  = 0.000;
    b7ss_V1  = 0.000; a7ss_V1  = 0.000;
    b8ss_V1  = 0.000; a8ss_V1  = 0.000;
    b9ss_V1  = 0.000; a9ss_V1  = 0.000;
    b10ss_V1 = 0.000; a10ss_V1 = 0.000;
    b11ss_V1 = 0.000; a11ss_V1 = 0.000;
    b12ss_V1 = 0.000; a12ss_V1 = 0.000;
    b13ss_V1 = 0.000; a13ss_V1 = 0.000;
    b14ss_V1 = 0.000; a14ss_V1 = 0.000;
    b15ss_V1 = 0.000; a15ss_V1 = 0.000;

    b1ss_V2  = 0.000; a1ss_V2  = 0.000;
    b2ss_V2  = 0.000; a2ss_V2  = 0.000;
    b3ss_V2  = 0.000; a3ss_V2  = 0.000;
    b4ss_V2  = 0.000; a4ss_V2  = 0.000;
    b5ss_V2  = 0.000; a5ss_V2  = 0.000;
    b6ss_V2  = 0.000; a6ss_V2  = 0.000;
    b7ss_V2  = 0.000; a7ss_V2  = 0.000;
    b8ss_V2  = 0.000; a8ss_V2  = 0.000;
    b9ss_V2  = 0.000; a9ss_V2  = 0.000;
    b10ss_V2 = 0.000; a10ss_V2 = 0.000;
    b11ss_V2 = 0.000; a11ss_V2 = 0.000;
    b12ss_V2 = 0.000; a12ss_V2 = 0.000;
    b13ss_V2 = 0.000; a13ss_V2 = 0.000;
    b14ss_V2 = 0.000; a14ss_V2 = 0.000;
    b15ss_V2 = 0.000; a15ss_V2 = 0.000;
  } else {
    b1ss_V1  = b1M_typm_V1_nrj  + b1ss_U ; a1ss_V1  = a1M_typm_V1_nrj  + a1ss_U ;
    b2ss_V1  = b2M_typm_V1_nrj  + b2ss_U ; a2ss_V1  = a2M_typm_V1_nrj  + a2ss_U ;
    b3ss_V1  = b3M_typm_V1_nrj  + b3ss_U ; a3ss_V1  = a3M_typm_V1_nrj  + a3ss_U ;
    b4ss_V1  = b4M_typm_V1_nrj  + b4ss_U ; a4ss_V1  = a4M_typm_V1_nrj  + a4ss_U ;
    b5ss_V1  = b5M_typm_V1_nrj  + b5ss_U ; a5ss_V1  = a5M_typm_V1_nrj  + a5ss_U ;
    b6ss_V1  = b6M_typm_V1_nrj  + b6ss_U ; a6ss_V1  = a6M_typm_V1_nrj  + a6ss_U ;
    b7ss_V1  = b7M_typm_V1_nrj  + b7ss_U ; a7ss_V1  = a7M_typm_V1_nrj  + a7ss_U ;
    b8ss_V1  = b8M_typm_V1_nrj  + b8ss_U ; a8ss_V1  = a8M_typm_V1_nrj  + a8ss_U ;
    b9ss_V1  = b9M_typm_V1_nrj  + b9ss_U ; a9ss_V1  = a9M_typm_V1_nrj  + a9ss_U ;
    b10ss_V1 = b10M_typm_V1_nrj + b10ss_U; a10ss_V1 = a10M_typm_V1_nrj + a10ss_U;
    b11ss_V1 = b11M_typm_V1_nrj + b11ss_U; a11ss_V1 = a11M_typm_V1_nrj + a11ss_U;
    b12ss_V1 = b12M_typm_V1_nrj + b12ss_U; a12ss_V1 = a12M_typm_V1_nrj + a12ss_U;
    b13ss_V1 = b13M_typm_V1_nrj + b13ss_U; a13ss_V1 = a13M_typm_V1_nrj + a13ss_U;
    b14ss_V1 = b14M_typm_V1_nrj + b14ss_U; a14ss_V1 = a14M_typm_V1_nrj + a14ss_U;
    b15ss_V1 = b15M_typm_V1_nrj + b15ss_U; a15ss_V1 = a15M_typm_V1_nrj + a15ss_U;

    b1ss_V2  = b1M_typm_V2_nrj  + (mmmqqq)*b1ss_U ; a1ss_V2  = a1M_typm_V2_nrj  + (mmmbbb)*a1ss_U ;
    b2ss_V2  = b2M_typm_V2_nrj  + (mmmbbb)*b2ss_U ; a2ss_V2  = a2M_typm_V2_nrj  + (mmmqqq)*a2ss_U ;
    b3ss_V2  = b3M_typm_V2_nrj  + (mmmqqq)*b3ss_U ; a3ss_V2  = a3M_typm_V2_nrj  + (mmmbbb)*a3ss_U ;
    b4ss_V2  = b4M_typm_V2_nrj  + (mmmbbb)*b4ss_U ; a4ss_V2  = a4M_typm_V2_nrj  + (mmmqqq)*a4ss_U ;
    b5ss_V2  = b5M_typm_V2_nrj  + (mmmqqq)*b5ss_U ; a5ss_V2  = a5M_typm_V2_nrj  + (mmmbbb)*a5ss_U ;
    b6ss_V2  = b6M_typm_V2_nrj  + (mmmbbb)*b6ss_U ; a6ss_V2  = a6M_typm_V2_nrj  + (mmmqqq)*a6ss_U ;
    b7ss_V2  = b7M_typm_V2_nrj  + (mmmqqq)*b7ss_U ; a7ss_V2  = a7M_typm_V2_nrj  + (mmmbbb)*a7ss_U ;
    b8ss_V2  = b8M_typm_V2_nrj  + (mmmbbb)*b8ss_U ; a8ss_V2  = a8M_typm_V2_nrj  + (mmmqqq)*a8ss_U ;
    b9ss_V2  = b9M_typm_V2_nrj  + (mmmqqq)*b9ss_U ; a9ss_V2  = a9M_typm_V2_nrj  + (mmmbbb)*a9ss_U ;
    b10ss_V2 = b10M_typm_V2_nrj + (mmmbbb)*b10ss_U; a10ss_V2 = a10M_typm_V2_nrj + (mmmqqq)*a10ss_U;
    b11ss_V2 = b11M_typm_V2_nrj + (mmmqqq)*b11ss_U; a11ss_V2 = a11M_typm_V2_nrj + (mmmbbb)*a11ss_U;
    b12ss_V2 = b12M_typm_V2_nrj + (mmmbbb)*b12ss_U; a12ss_V2 = a12M_typm_V2_nrj + (mmmqqq)*a12ss_U;
    b13ss_V2 = b13M_typm_V2_nrj + (mmmqqq)*b13ss_U; a13ss_V2 = a13M_typm_V2_nrj + (mmmbbb)*a13ss_U;
    b14ss_V2 = b14M_typm_V2_nrj + (mmmbbb)*b14ss_U; a14ss_V2 = a14M_typm_V2_nrj + (mmmqqq)*a14ss_U;
    b15ss_V2 = b15M_typm_V2_nrj + (mmmqqq)*b15ss_U; a15ss_V2 = a15M_typm_V2_nrj + (mmmbbb)*a15ss_U;
  };
};


  !Calculate the actual average (bn,an) of a given 2-in-1 dipole family type typm
  !for a given seed and at a GIVEN NRJ given in the sample job
new_magnetfamily_MB(typm) : macro ={
  if (print_errors==1){print,text="Magnet family (MB): typm";};
  exec,define_uncertainty(typm);
  yfact=-1;
  if (NRJ<4999.99){exec,new_magnetfamily_2in1(typm,inj,$yfact,1);};
  if (NRJ>4999.99){exec,new_magnetfamily_2in1(typm,col,$yfact,1);};
};


  !Calculate the actual average (bn,an) of a given 2-in-1 quadrupole family type typm 
  !for a given seed and at a GIVEN NRJ given in the sample job
new_magnetfamily_MQ(typm) : macro ={
  if (print_errors==1){ print,text="Magnet family (MQ): typm";};
  exec,define_uncertainty(typm);
  yfact=-1;
  if (NRJ<4999.99){exec,new_magnetfamily_2in1(typm,inj,1,$yfact);};
  if (NRJ>4999.99){exec,new_magnetfamily_2in1(typm,col,1,$yfact);};
};


new_magnetindividual_mult(typm,nrj) : macro ={
  if (use_uniform_error_distribution==1){
    print,text="Using uniform distribution for individual magnet from Magnet family : typm (nrj)";
    printf, text="b1T-b15T: %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F",
      value=b1T_typm_nrj ,b2T_typm_nrj ,b3T_typm_nrj ,b4T_typm_nrj ,b5T_typm_nrj,
            b6T_typm_nrj ,b7T_typm_nrj ,b8T_typm_nrj ,b9T_typm_nrj ,b10T_typm_nrj,
            b11T_typm_nrj,b12T_typm_nrj,b13T_typm_nrj,b14T_typm_nrj,b15T_typm_nrj;
    printf, text="a1T-a15T: %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F",
      value=a1T_typm_nrj ,a2T_typm_nrj ,a3T_typm_nrj ,a4T_typm_nrj ,a5T_typm_nrj,
            a6T_typm_nrj ,a7T_typm_nrj ,a8T_typm_nrj ,a9T_typm_nrj ,a10T_typm_nrj,
            a11T_typm_nrj,a12T_typm_nrj,a13T_typm_nrj,a14T_typm_nrj,a15T_typm_nrj;
    printf, text="b1L-b15L: %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F",
      value=b1L_typm_nrj ,b2L_typm_nrj ,b3L_typm_nrj ,b4L_typm_nrj ,b5L_typm_nrj,
            b6L_typm_nrj ,b7L_typm_nrj ,b8L_typm_nrj ,b9L_typm_nrj ,b10L_typm_nrj,
            b11L_typm_nrj,b12L_typm_nrj,b13L_typm_nrj,b14L_typm_nrj,b15L_typm_nrj;
    printf, text="a1L-a15L: %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F",
      value=a1L_typm_nrj ,a2L_typm_nrj ,a3L_typm_nrj ,a4L_typm_nrj ,a5L_typm_nrj,
            a6L_typm_nrj ,a7L_typm_nrj ,a8L_typm_nrj ,a9L_typm_nrj ,a10L_typm_nrj,
            a11L_typm_nrj,a12L_typm_nrj,a13L_typm_nrj,a14L_typm_nrj,a15L_typm_nrj;
            
    
    printf, text="b3T_typm_nrj: %F, b3M_typm_nrj: %F, b3R_typm_nrj: %F",
      value=b3T_typm_nrj ,b3M_typm_nrj ,b3R_typm_nrj;

    b1dd  = ( b1T_typm_nrj  - b1L_typm_nrj  ); a1dd  = ( a1T_typm_nrj  - a1L_typm_nrj  );
    b2dd  = ( b2T_typm_nrj  - b2L_typm_nrj  ); a2dd  = ( a2T_typm_nrj  - a2L_typm_nrj  );
    b3dd  = ( b3T_typm_nrj  - b3L_typm_nrj  ); a3dd  = ( a3T_typm_nrj  - a3L_typm_nrj  );
    b4dd  = ( b4T_typm_nrj  - b4L_typm_nrj  ); a4dd  = ( a4T_typm_nrj  - a4L_typm_nrj  );
    b5dd  = ( b5T_typm_nrj  - b5L_typm_nrj  ); a5dd  = ( a5T_typm_nrj  - a5L_typm_nrj  );
    b6dd  = ( b6T_typm_nrj  - b6L_typm_nrj  ); a6dd  = ( a6T_typm_nrj  - a6L_typm_nrj  );
    b7dd  = ( b7T_typm_nrj  - b7L_typm_nrj  ); a7dd  = ( a7T_typm_nrj  - a7L_typm_nrj  );
    b8dd  = ( b8T_typm_nrj  - b8L_typm_nrj  ); a8dd  = ( a8T_typm_nrj  - a8L_typm_nrj  );
    b9dd  = ( b9T_typm_nrj  - b9L_typm_nrj  ); a9dd  = ( a9T_typm_nrj  - a9L_typm_nrj  );
    b10dd = ( b10T_typm_nrj - b10L_typm_nrj ); a10dd = ( a10T_typm_nrj - a01L_typm_nrj );
    b11dd = ( b11T_typm_nrj - b11L_typm_nrj ); a11dd = ( a11T_typm_nrj - a11L_typm_nrj );
    b12dd = ( b12T_typm_nrj - b12L_typm_nrj ); a12dd = ( a12T_typm_nrj - a12L_typm_nrj );
    b13dd = ( b13T_typm_nrj - b13L_typm_nrj ); a13dd = ( a13T_typm_nrj - a13L_typm_nrj );
    b14dd = ( b14T_typm_nrj - b14L_typm_nrj ); a14dd = ( a14T_typm_nrj - a14L_typm_nrj );
    b15dd = ( b15T_typm_nrj - b15L_typm_nrj ); a15dd = ( a15T_typm_nrj - a15L_typm_nrj );

    b1ssr   = 1E-4 * (ON_B1R  * ( b1dd  * RANF() + b1L_typm_nrj  ) );
    b2ssr   = 1E-4 * (ON_B2R  * ( b2dd  * RANF() + b2L_typm_nrj  ) );
    b3ssr   = 1E-4 * (ON_B3R  * ( b3dd  * RANF() + b3L_typm_nrj  ) );
    b4ssr   = 1E-4 * (ON_B4R  * ( b4dd  * RANF() + b4L_typm_nrj  ) );
    b5ssr   = 1E-4 * (ON_B5R  * ( b5dd  * RANF() + b5L_typm_nrj  ) );
    b6ssr   = 1E-4 * (ON_B6R  * ( b6dd  * RANF() + b6L_typm_nrj  ) );
    b7ssr   = 1E-4 * (ON_B7R  * ( b7dd  * RANF() + b7L_typm_nrj  ) );
    b8ssr   = 1E-4 * (ON_B8R  * ( b8dd  * RANF() + b8L_typm_nrj  ) );
    b9ssr   = 1E-4 * (ON_B9R  * ( b9dd  * RANF() + b9L_typm_nrj  ) );
    b10ssr  = 1E-4 * (ON_B10R * ( b10dd * RANF() + b10L_typm_nrj ) );
    b11ssr  = 1E-4 * (ON_B11R * ( b11dd * RANF() + b11L_typm_nrj ) );
    b12ssr  = 1E-4 * (ON_B12R * ( b12dd * RANF() + b12L_typm_nrj ) );
    b13ssr  = 1E-4 * (ON_B13R * ( b13dd * RANF() + b13L_typm_nrj ) );
    b14ssr  = 1E-4 * (ON_B14R * ( b14dd * RANF() + b14L_typm_nrj ) );
    b15ssr  = 1E-4 * (ON_B15R * ( b15dd * RANF() + b15L_typm_nrj ) );

    a1ssr   = 1E-4 * (ON_A1R  * ( a1dd  * RANF() + a1L_typm_nrj  ) );
    a2ssr   = 1E-4 * (ON_A2R  * ( a2dd  * RANF() + a2L_typm_nrj  ) );
    a3ssr   = 1E-4 * (ON_A3R  * ( a3dd  * RANF() + a3L_typm_nrj  ) );
    a4ssr   = 1E-4 * (ON_A4R  * ( a4dd  * RANF() + a4L_typm_nrj  ) );
    a5ssr   = 1E-4 * (ON_A5R  * ( a5dd  * RANF() + a5L_typm_nrj  ) );
    a6ssr   = 1E-4 * (ON_A6R  * ( a6dd  * RANF() + a6L_typm_nrj  ) );
    a7ssr   = 1E-4 * (ON_A7R  * ( a7dd  * RANF() + a7L_typm_nrj  ) );
    a8ssr   = 1E-4 * (ON_A8R  * ( a8dd  * RANF() + a8L_typm_nrj  ) );
    a9ssr   = 1E-4 * (ON_A9R  * ( a9dd  * RANF() + a9L_typm_nrj  ) );
    a10ssr  = 1E-4 * (ON_A10R * ( a10dd * RANF() + a10L_typm_nrj ) );
    a11ssr  = 1E-4 * (ON_A11R * ( a11dd * RANF() + a11L_typm_nrj ) );
    a12ssr  = 1E-4 * (ON_A12R * ( a12dd * RANF() + a12L_typm_nrj ) );
    a13ssr  = 1E-4 * (ON_A13R * ( a13dd * RANF() + a13L_typm_nrj ) );
    a14ssr  = 1E-4 * (ON_A14R * ( a14dd * RANF() + a14L_typm_nrj ) );
    a15ssr  = 1E-4 * (ON_A15R * ( a15dd * RANF() + a15L_typm_nrj ) );
  } else {
    b1ssr   = 1E-4 * (ON_B1S  * b1ss   + ON_B1R  * b1R_typm_nrj   * TGAUSS(3.) );
    b2ssr   = 1E-4 * (ON_B2S  * b2ss   + ON_B2R  * b2R_typm_nrj   * TGAUSS(3.) );
    b3ssr   = 1E-4 * (ON_B3S  * b3ss   + ON_B3R  * b3R_typm_nrj   * TGAUSS(3.) );
    b4ssr   = 1E-4 * (ON_B4S  * b4ss   + ON_B4R  * b4R_typm_nrj   * TGAUSS(3.) );
    b5ssr   = 1E-4 * (ON_B5S  * b5ss   + ON_B5R  * b5R_typm_nrj   * TGAUSS(3.) );
    b6ssr   = 1E-4 * (ON_B6S  * b6ss   + ON_B6R  * b6R_typm_nrj   * TGAUSS(3.) );
    b7ssr   = 1E-4 * (ON_B7S  * b7ss   + ON_B7R  * b7R_typm_nrj   * TGAUSS(3.) );
    b8ssr   = 1E-4 * (ON_B8S  * b8ss   + ON_B8R  * b8R_typm_nrj   * TGAUSS(3.) );
    b9ssr   = 1E-4 * (ON_B9S  * b9ss   + ON_B9R  * b9R_typm_nrj   * TGAUSS(3.) );
    b10ssr  = 1E-4 * (ON_B10S * b10ss  + ON_B10R * b10R_typm_nrj  * TGAUSS(3.) );
    b11ssr  = 1E-4 * (ON_B11S * b11ss  + ON_B11R * b11R_typm_nrj  * TGAUSS(3.) );
    b12ssr  = 1E-4 * (ON_B12S * b12ss  + ON_B12R * b12R_typm_nrj  * TGAUSS(3.) );
    b13ssr  = 1E-4 * (ON_B13S * b13ss  + ON_B13R * b13R_typm_nrj  * TGAUSS(3.) );
    b14ssr  = 1E-4 * (ON_B14S * b14ss  + ON_B14R * b14R_typm_nrj  * TGAUSS(3.) );
    b15ssr  = 1E-4 * (ON_B15S * b15ss  + ON_B15R * b15R_typm_nrj  * TGAUSS(3.) );

    a1ssr   = 1E-4 * (ON_A1S  * a1ss   + ON_A1R  * a1R_typm_nrj   * TGAUSS(3.) );
    a2ssr   = 1E-4 * (ON_A2S  * a2ss   + ON_A2R  * a2R_typm_nrj   * TGAUSS(3.) );
    a3ssr   = 1E-4 * (ON_A3S  * a3ss   + ON_A3R  * a3R_typm_nrj   * TGAUSS(3.) );
    a4ssr   = 1E-4 * (ON_A4S  * a4ss   + ON_A4R  * a4R_typm_nrj   * TGAUSS(3.) );
    a5ssr   = 1E-4 * (ON_A5S  * a5ss   + ON_A5R  * a5R_typm_nrj   * TGAUSS(3.) );
    a6ssr   = 1E-4 * (ON_A6S  * a6ss   + ON_A6R  * a6R_typm_nrj   * TGAUSS(3.) );
    a7ssr   = 1E-4 * (ON_A7S  * a7ss   + ON_A7R  * a7R_typm_nrj   * TGAUSS(3.) );
    a8ssr   = 1E-4 * (ON_A8S  * a8ss   + ON_A8R  * a8R_typm_nrj   * TGAUSS(3.) );
    a9ssr   = 1E-4 * (ON_A9S  * a9ss   + ON_A9R  * a9R_typm_nrj   * TGAUSS(3.) );
    a10ssr  = 1E-4 * (ON_A10S * a10ss  + ON_A10R * a10R_typm_nrj  * TGAUSS(3.) );
    a11ssr  = 1E-4 * (ON_A11S * a11ss  + ON_A11R * a11R_typm_nrj  * TGAUSS(3.) );
    a12ssr  = 1E-4 * (ON_A12S * a12ss  + ON_A12R * a12R_typm_nrj  * TGAUSS(3.) );
    a13ssr  = 1E-4 * (ON_A13S * a13ss  + ON_A13R * a13R_typm_nrj  * TGAUSS(3.) );
    a14ssr  = 1E-4 * (ON_A14S * a14ss  + ON_A14R * a14R_typm_nrj  * TGAUSS(3.) );
    a15ssr  = 1E-4 * (ON_A15S * a15ss  + ON_A15R * a15R_typm_nrj  * TGAUSS(3.) );
  };
};


choose_magnet_ap(iap):  macro ={
  b1ss  = b1ss_Viap ;a1ss  = a1ss_Viap ;
  b2ss  = b2ss_Viap ;a2ss  = a2ss_Viap ;
  b3ss  = b3ss_Viap ;a3ss  = a3ss_Viap ;
  b4ss  = b4ss_Viap ;a4ss  = a4ss_Viap ;
  b5ss  = b5ss_Viap ;a5ss  = a5ss_Viap ;
  b6ss  = b6ss_Viap ;a6ss  = a6ss_Viap ;
  b7ss  = b7ss_Viap ;a7ss  = a7ss_Viap ;
  b8ss  = b8ss_Viap ;a8ss  = a8ss_Viap ;
  b9ss  = b9ss_Viap ;a9ss  = a9ss_Viap ;
  b10ss = b10ss_Viap;a10ss = a10ss_Viap;
  b11ss = b11ss_Viap;a11ss = a11ss_Viap;
  b12ss = b12ss_Viap;a12ss = a12ss_Viap;
  b13ss = b13ss_Viap;a13ss = a13ss_Viap;
  b14ss = b14ss_Viap;a14ss = a14ss_Viap;
  b15ss = b15ss_Viap;a15ss = a15ss_Viap;
};


new_magnetindividual(typm,iap) : macro ={
    !Calculate the actual (bn,an) of a given magnet belonging to family typm
    !for a given seed and at a GIVEN NRJ given in the sample job
    !iap=0/1/2 for single bore/outer/inner
  iapaux=iap;
  if (print_errors==1){
    if(iapaux==0) {print,text="typm: single bore magnet";};
    if(iapaux==1) {print,text="typm: 2-in-1 magnet: outer channel";};
    if(iapaux==2) {print,text="typm: 2-in-1 magnet: inner channel";};
  };

  if(iapaux>0){ exec,choose_magnet_ap($iapaux); };
  if (NRJ<4999.99){ exec,new_magnetindividual_mult(typm,inj);};
  if (NRJ>4999.99){ exec,new_magnetindividual_mult(typm,col);};
};


errorgenerate_dip(typm) : macro ={
  is_inv=0;order=0;
  exec, errorgenerate_rel(typm,$is_inv,$order);
};


errorgenerate_dip_inv(typm) : macro ={
  is_inv=1;order=0;
  exec, errorgenerate_rel(typm,$is_inv,$order);
};


errorgenerate_quad(typm) : macro ={
  is_inv=0;order=1;
  exec, errorgenerate_rel(typm,$is_inv,$order);
};


errorgenerate_quad_inv(typm) : macro ={
  is_inv=1;order=1;
  exec, errorgenerate_rel(typm,$is_inv,$order);
};


  ! magnetic measurement conventions: `magnetic_sign`=1
  ! apply sign change to measured field quality when beam 1 (or 2)  enters in aperture from connection side
  ! don't apply changes to measured field quality when beam 4 exit from connection sides
  ! order ooo is specified in terms of KL: 0=dipole, 1=quadrupole, etc...
  ! negative reference radius for a skew main field (An)
errorgenerate_signs(rref,is_inv,ooo,aaa,bbb) : macro ={
    ! There are 3 effects that cause a sign flip: beam4, an inverted magnet
    ! (connection side opposite to beam direction), and the magnetic convention.
    ! These three are combined in yfact
  if (mylhcbeam==4) {is_beam4=1;} else {is_beam4=0;};
  yfact=(-1)^(magnetic_sign+is_beam4+is_inv);           ! number of x-sign flips

    ! If we have an odd number of sign flips (yfact=-1),
    ! then we change the appropriate multipoles (odd an, even bn) 
  aaa=yfact;
  bbb=1;

    ! In case of a sign flip, the main field changes sign as well if skew
    ! and even order or if regular and odd order (order as from KL, not A/B).
    ! Example: A1, B2, A3, B4, ...
    ! Instead of changing the main field sign, we change all multipoles.
    ! However, in case of Beam 4, we shouldn't change signs as this is then
    ! already done in optics (due to the bv_aux flag), unless we define the
    ! main field separately in which case we have to multiply it with bv_aux
    ! in its error routine (eg MCBXF).
    ! Skew main fields are recognised by a negative reference radius.
!  if (rref/(abs(rref))==-1) {is_skew=1;} else {is_skew=0;};
!  yfactref=(-1)^(magnetic_sign+is_inv);
!  if (yfactref==-1){ ! odd x-sign flips
!     sign=(-1)^(is_skew+ooo);  ! change all signs in case A1, B2, .. are main fields
!     aaa=sign*aaa;
!     bbb=sign*bbb;
!  };

    ! In case of a sign flip, the main field changes sign as well if it is skew
    ! and even order or if it is regular and odd order (order as from KL, not A/B).
    ! Example: A1, B2, A3, B4, ...
    ! Instead of changing the main field sign, we change all multipoles.
  if (rref/(abs(rref))==-1) {is_skew=1;} else {is_skew=0;};
  if (yfact==-1){               ! odd x-sign flips
     sign=(-1)^(is_skew+ooo);  ! change all signs in case A1, B2, .. are main fields
     aaa=sign*aaa;
     bbb=sign*bbb;
  };

};


errorgenerate_rel(typm,is_inv,ooo) : macro ={
  rref=Rr_typm;
  exec, errorgenerate_signs(rref,is_inv,ooo,aaa,bbb);

  Efcomp, radius = rref, order= ooo,
  dknr:={bbb*b1ssr ,aaa*b2ssr ,bbb*b3ssr ,aaa*b4ssr ,bbb*b5ssr,
        aaa*b6ssr, bbb*b7ssr ,aaa*b8ssr ,bbb*b9ssr ,aaa*b10ssr,
        bbb*b11ssr,aaa*b12ssr,bbb*b13ssr,aaa*b14ssr,bbb*b15ssr},
  dksr:={aaa*a1ssr ,bbb*a2ssr ,aaa*a3ssr ,bbb*a4ssr ,aaa*a5ssr,
        bbb*a6ssr, aaa*a7ssr ,bbb*a8ssr ,aaa*a9ssr ,bbb*a10ssr,
        aaa*a11ssr,bbb*a12ssr,aaa*a13ssr,bbb*a14ssr,aaa*a15ssr};
  if (print_errors==1){
    printf, text="b1-b15: %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F",
      value=1E4*bbb*b1ssr ,1E4*aaa*b2ssr ,1E4*bbb*b3ssr ,1E4*aaa*b4ssr ,1E4*bbb*b5ssr,
            1E4*aaa*b6ssr ,1E4*bbb*b7ssr ,1E4*aaa*b8ssr ,1E4*bbb*b9ssr ,1E4*aaa*b10ssr,
            1E4*bbb*b11ssr,1E4*aaa*b12ssr,1E4*bbb*b13ssr,1E4*aaa*b14ssr,1E4*bbb*b15ssr;
    printf, text="a1-a15: %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F",
      value=1E4*aaa*a1ssr ,1E4*bbb*a2ssr ,1E4*aaa*a3ssr ,1E4*bbb*a4ssr ,1E4*aaa*a5ssr,
            1E4*bbb*a6ssr ,1E4*aaa*a7ssr ,1E4*bbb*a8ssr ,1E4*aaa*a9ssr ,1E4*bbb*a10ssr,
            1E4*aaa*a11ssr,1E4*bbb*a12ssr,1E4*aaa*a13ssr,1E4*bbb*a14ssr,1E4*aaa*a15ssr;
  };
};


errorgenerate_abs(typm,is_inv,ooo,klref): macro={
  rref=Rr_typm;
  exec, errorgenerate_signs(rref,is_inv,ooo,aaa,bbb);
  rref=abs(rref);
  
    ! The signs are assigned with errorgenerate_signs, which takes into
    ! account the orientation of the magnet, B1 vs B4, and the main field. 
    ! However, in case of Beam 4, we shouldn't have taken the main field
    ! into account, as this is already accounted for in the optics (due to
    ! the bv_aux flag). So we need to correct this:
  if (mylhcbeam==4) {
    sign=(-1)^(is_skew+ooo);
    aaa=sign*aaa;
    bbb=sign*bbb;
  };
    ! Note that in the specific case where the main field is defined
    ! manually (as is the case for e.g. the MCBXF), we have to multiply
    ! the main field manually with bv_aux in its error routine!

  n = 1; orderfact = 1;
  WHILE (n <= ooo) {
    orderfact = n*orderfact;
    n = n+1;
  };
  erfact1=klref*(rref)^(ooo)/orderfact;
  erfact2=erfact1*1/rref;
  erfact3=erfact2*2/rref; erfact4=erfact3*3/rref;
  erfact5=erfact4*4/rref; erfact6=erfact5*5/rref;
  erfact7=erfact6*6/rref; erfact8=erfact7*7/rref;
  erfact9=erfact8*8/rref; erfact10=erfact9*9/rref;
  erfact11=erfact10*10/rref; erfact12=erfact11*11/rref;
  erfact13=erfact12*12/rref; erfact14=erfact13*13/rref;
  erfact15=erfact14*14/rref;

  efcomp,
  dkn:={ bbb*b1ssr*erfact1,  aaa*b2ssr*erfact2,  bbb*b3ssr*erfact3 ,
         aaa*b4ssr*erfact4,  bbb*b5ssr*erfact5,  aaa*b6ssr*erfact6 ,
         bbb*b7ssr*erfact7,  aaa*b8ssr*erfact8,  bbb*b9ssr*erfact9 ,
         aaa*b10ssr*erfact10,bbb*b11ssr*erfact11,aaa*b12ssr*erfact12,
         bbb*b13ssr*erfact13,aaa*b14ssr*erfact14,bbb*b15ssr*erfact15},
  dks:={ aaa*a1ssr*erfact1,  bbb*a2ssr*erfact2,  aaa*a3ssr*erfact3 ,
         bbb*a4ssr*erfact4,  aaa*a5ssr*erfact5,  bbb*a6ssr*erfact6 ,
         aaa*a7ssr*erfact7,  bbb*a8ssr*erfact8,  aaa*a9ssr*erfact9 ,
         bbb*a10ssr*erfact10,aaa*a11ssr*erfact11,bbb*a12ssr*erfact12,
         aaa*a13ssr*erfact13,bbb*a14ssr*erfact14,aaa*a15ssr*erfact15 };
  if (print_errors==1){
    printf, text="b1-b15: %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F",
      value=1E4*bbb*b1ssr ,1E4*aaa*b2ssr ,1E4*bbb*b3ssr ,1E4*aaa*b4ssr ,1E4*bbb*b5ssr,
            1E4*aaa*b6ssr ,1E4*bbb*b7ssr ,1E4*aaa*b8ssr ,1E4*bbb*b9ssr ,1E4*aaa*b10ssr,
            1E4*bbb*b11ssr,1E4*aaa*b12ssr,1E4*bbb*b13ssr,1E4*aaa*b14ssr,1E4*bbb*b15ssr;
    printf, text="a1-a15: %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F, %F",
      value=1E4*aaa*a1ssr ,1E4*bbb*a2ssr ,1E4*aaa*a3ssr ,1E4*bbb*a4ssr ,1E4*aaa*a5ssr,
            1E4*bbb*a6ssr ,1E4*aaa*a7ssr ,1E4*bbb*a8ssr ,1E4*aaa*a9ssr ,1E4*bbb*a10ssr,
            1E4*aaa*a11ssr,1E4*bbb*a12ssr,1E4*aaa*a13ssr,1E4*bbb*a14ssr,1E4*aaa*a15ssr;
  };
};


show_error_newHLmagnet : macro ={
  select,flag=error,clear;
  select,flag=error,pattern="^MBXA\..*\.\..*$";
  select,flag=error,pattern="^MBXB\..*\.\..*$";
  select,flag=error,pattern="^MBRD\..*\.\..*$";
  select,flag=error,pattern="^MQXC\..*\.\..*$";
  select,flag=error,pattern="^MQXD\..*\.\..*$";
  select,flag=error,pattern="^MQXFA\..*\.\..*$";
  select,flag=error,pattern="^MQXFB\..*\.\..*$";
  select,flag=error,pattern="^MCBXFA\..*\.\..*$";
  select,flag=error,pattern="^MCBXFB\..*\.\..*$";
  select,flag=error,pattern="^MQYY\..*\.\..*$";
  select,flag=error,pattern="^MQYL\..*\.\..*$";
  select,flag=error,pattern="^MBH\..*\.\..*$";
  esave;
};

reset_MB_corr : macro ={
  if(mylhcbeam==1){
    system," echo 'Reset settings of all arc correctors for beam 1'";
    dKQTF.a12b1:=0.;dKQTD.a12b1:=0.;
    dKQTF.a23b1:=0.;dKQTD.a23b1:=0.;
    dKQTF.a34b1:=0.;dKQTD.a34b1:=0.;
    dKQTF.a45b1:=0.;dKQTD.a45b1:=0.;
    dKQTF.a56b1:=0.;dKQTD.a56b1:=0.;
    dKQTF.a67b1:=0.;dKQTD.a67b1:=0.;
    dKQTF.a78b1:=0.;dKQTD.a78b1:=0.;
    dKQTF.a81b1:=0.;dKQTD.a81b1:=0.;
    KQS.A23b1:=0.;
    KQS.A45b1:=0.;
    KQS.A67b1:=0.;
    KQS.A81b1:=0.;
    KQS.R1b1:=0;KQS.L2b1:=0.;
    KQS.R3b1:=0;KQS.L4b1:=0.;
    KQS.R5b1:=0;KQS.L6b1:=0.;
    KQS.R7b1:=0;KQS.L8b1:=0.;
    KSS.a12b1:=0.;KCS.a12b1:=0.;KCO.a12b1:=0.;KCD.a12b1:=0.;
    KSS.a23b1:=0.;KCS.a23b1:=0.;KCO.a23b1:=0.;KCD.a23b1:=0.;
    KSS.a34b1:=0.;KCS.a34b1:=0.;KCO.a34b1:=0.;KCD.a34b1:=0.;
    KSS.a45b1:=0.;KCS.a45b1:=0.;KCO.a45b1:=0.;KCD.a45b1:=0.;
    KSS.a56b1:=0.;KCS.a56b1:=0.;KCO.a56b1:=0.;KCD.a56b1:=0.;
    KSS.a67b1:=0.;KCS.a67b1:=0.;KCO.a67b1:=0.;KCD.a67b1:=0.;
    KSS.a78b1:=0.;KCS.a78b1:=0.;KCO.a78b1:=0.;KCD.a78b1:=0.;
    KSS.a81b1:=0.;KCS.a81b1:=0.;KCO.a81b1:=0.;KCD.a81b1:=0.;
  };
  if(mylhcbeam > 1){
    system," echo 'Reset settings of all arc correctors for beam 2/4'";
    dKQTF.a12b2:=0.;dKQTD.a12b2:=0.;
    dKQTF.a23b2:=0.;dKQTD.a23b2:=0.;
    dKQTF.a34b2:=0.;dKQTD.a34b2:=0.;
    dKQTF.a45b2:=0.;dKQTD.a45b2:=0.;
    dKQTF.a56b2:=0.;dKQTD.a56b2:=0.;
    dKQTF.a67b2:=0.;dKQTD.a67b2:=0.;
    dKQTF.a78b2:=0.;dKQTD.a78b2:=0.;
    dKQTF.a81b2:=0.;dKQTD.a81b2:=0.;
    KQS.A12b2:=0.;
    KQS.A34b2:=0.;
    KQS.A56b2:=0.;
    KQS.A78b2:=0.;
    KQS.R2b2:=0;KQS.L3b2:=0.;
    KQS.R4b2:=0;KQS.L5b2:=0.;
    KQS.R6b2:=0;KQS.L7b2:=0.;
    KQS.R8b2:=0;KQS.L1b2:=0.;
    KSS.a12b2:=0.;KCS.a12b2:=0.;KCO.a12b2:=0.;KCD.a12b2:=0.;
    KSS.a23b2:=0.;KCS.a23b2:=0.;KCO.a23b2:=0.;KCD.a23b2:=0.;
    KSS.a34b2:=0.;KCS.a34b2:=0.;KCO.a34b2:=0.;KCD.a34b2:=0.;
    KSS.a45b2:=0.;KCS.a45b2:=0.;KCO.a45b2:=0.;KCD.a45b2:=0.;
    KSS.a56b2:=0.;KCS.a56b2:=0.;KCO.a56b2:=0.;KCD.a56b2:=0.;
    KSS.a67b2:=0.;KCS.a67b2:=0.;KCO.a67b2:=0.;KCD.a67b2:=0.;
    KSS.a78b2:=0.;KCS.a78b2:=0.;KCO.a78b2:=0.;KCD.a78b2:=0.;
    KSS.a81b2:=0.;KCS.a81b2:=0.;KCO.a81b2:=0.;KCD.a81b2:=0.;
  };
};


reset_MQX_corr : macro ={
  system," echo 'Reset settings of all triplet correctors'";
  !a2
  KQSXF.L1:=0;KQSXF.R1:=0;
  KQSXF.L2:=0;KQSXF.R2:=0;
  KQSXF.L5:=0;KQSXF.R5:=0;
  KQSXF.L8:=0;KQSXF.R8:=0;
  !a3
  KCSSXF.L1:=0;KCSSXF.R1:=0;
  KCSSXF.L2:=0;KCSSXF.R2:=0;
  KCSSXF.L5:=0;KCSSXF.R5:=0;
  KCSSXF.L8:=0;KCSSXF.R8:=0;
  !a4
  KCOSXF.L1:=0;KCOSXF.R1:=0;
  KCOSXF.L2:=0;KCOSXF.R2:=0;
  KCOSXF.L5:=0;KCOSXF.R5:=0;
  KCOSXF.L8:=0;KCOSXF.R8:=0;
  !a5
  KCDSXF.L1:=0;KCDSXF.R1:=0;
  KCDSXF.L2:=0;KCDSXF.R2:=0; ! DO NOT EXIST
  KCDSXF.L5:=0;KCDSXF.R5:=0;
  KCDSXF.L8:=0;KCDSXF.R8:=0; ! DO NOT EXIST
  !a6
  KCTSXF.L1:=0;KCTSXF.R1:=0;
  KCTSXF.L2:=0;KCTSXF.R2:=0; ! DO NOT EXIST
  KCTSXF.L5:=0;KCTSXF.R5:=0;
  KCTSXF.L8:=0;KCTSXF.R8:=0; ! DO NOT EXIST
  !b3
  KCSXF.L1:=0;KCSXF.R1:=0;
  KCSXF.L2:=0;KCSXF.R2:=0;
  KCSXF.L5:=0;KCSXF.R5:=0;
  KCSXF.L8:=0;KCSXF.R8:=0;
  !b4
  KCOXF.L1:=0;KCOXF.R1:=0;
  KCOXF.L2:=0;KCOXF.R2:=0;
  KCOXF.L5:=0;KCOXF.R5:=0;
  KCOXF.L8:=0;KCOXF.R8:=0;
  !b5
  KCDXF.L1:=0;KCDXF.R1:=0;
  KCDXF.L2:=0;KCDXF.R2:=0; ! DO NOT EXIST
  KCDXF.L5:=0;KCDXF.R5:=0;
  KCDXF.L8:=0;KCDXF.R8:=0; ! DO NOT EXIST
  !b6
  KCTXF.L1:=0;KCTXF.R1:=0;
  KCTXF.L2:=0;KCTXF.R2:=0;
  KCTXF.L5:=0;KCTXF.R5:=0;
  KCTXF.L8:=0;KCTXF.R8:=0;
};


average_of_randoms(to,from1,from2): macro={
  b1to = 0.5*( b1from1 + b1from2);
  b2to = 0.5*( b2from1 + b2from2);
  b3to = 0.5*( b3from1 + b3from2);
  b4to = 0.5*( b4from1 + b4from2);
  b5to = 0.5*( b5from1 + b5from2);
  b6to = 0.5*( b6from1 + b6from2);
  b7to = 0.5*( b7from1 + b7from2);
  b8to = 0.5*( b8from1 + b8from2);
  b9to = 0.5*( b9from1 + b9from2);
  b10to = 0.5*( b10from1 + b10from2);
  b11to = 0.5*( b11from1 + b11from2);
  b12to = 0.5*( b12from1 + b12from2);
  b13to = 0.5*( b13from1 + b13from2);
  b14to = 0.5*( b14from1 + b14from2);
  b15to = 0.5*( b15from1 + b15from2);
  a1to = 0.5*( a1from1 + a1from2);
  a2to = 0.5*( a2from1 + a2from2);
  a3to = 0.5*( a3from1 + a3from2);
  a4to = 0.5*( a4from1 + a4from2);
  a5to = 0.5*( a5from1 + a5from2);
  a6to = 0.5*( a6from1 + a6from2);
  a7to = 0.5*( a7from1 + a7from2);
  a8to = 0.5*( a8from1 + a8from2);
  a9to = 0.5*( a9from1 + a9from2);
  a10to = 0.5*( a10from1 + a10from2);
  a11to = 0.5*( a11from1 + a11from2);
  a12to = 0.5*( a12from1 + a12from2);
  a13to = 0.5*( a13from1 + a13from2);
  a14to = 0.5*( a14from1 + a14from2);
  a15to = 0.5*( a15from1 + a15from2);
};


assign_sign_from_optics(target,optic,max,threshold,include_sign_if_threshold): macro={
  exec, query_crossing;
  if (crossing_enabled==0){exec, crossing_restore;};
  if (crossing_enabled==-1){
    print,text="WARNING! Some crossing knobs (but not all) are off. This might give target a wrong setting ..";
  };
  limit_sign_by_threshold = abs(optic/(max*threshold));
  if (limit_sign_by_threshold <= 1) { 
    if (include_sign_if_threshold==0){
      target = abs(threshold);
    } else {
      target = abs(threshold)*optic/(abs(optic));
    };
  } else {
    target = optic/(abs(optic));
  };
  if (crossing_enabled==0){exec, crossing_disable;};
};


assign_optics_as_ref(target,optic,max): macro={
  exec, query_crossing;
  if (crossing_enabled==0){exec, crossing_restore;};
  if (crossing_enabled==-1){
    print,text="WARNING! Some crossing knobs (but not all) are off. This might give target a wrong setting ..";
  };
  target = optic/max;
  if (crossing_enabled==0){exec, crossing_disable;};
};


  ! Assign to magnet 'slot1' the errors read from magnet 'slot2'
Efcomp_Measured_Quad_Switch(slot1,slot2) : macro = {
  yrotangle := table(rotations, slot1, yrota);  // rotation around vertical axis
  srotangle := table(rotations, slot1, srota);  // rotation around beam axis
  inout     := table(rotations, slot1, inout);  // 0: single bore    1: outer     2: inner
  if (inout > 0 && mylhcbeam ==   2) {inout= 3 - inout;} ;    // beam 2 clockwise, bv=-1
  if (inout > 0 && mylhcbeam ==   3) {inout= 3 - inout;} ;    // beam 2 clockwise
  if (inout > 0 && mylhcbeam ==   4) {inout= 3 - inout;} ;    // beam 2 counter-clockwise
  if (inout > 0 && yrotangle == 180) {inout= 3 - inout;} ;    // rotated magnet
  if (inout == 0) {exec, Set_Quadru_Mult(slot1, slot2)   ;} ;
  if (inout == 1) {exec, Set_Quadru_Mult(slot1, slot2.v1);} ;
  if (inout == 2) {exec, Set_Quadru_Mult(slot1, slot2.v2);} ;
};






Efcomp_Random_Multi(typm, slot, abs_or_rel, order) : macro = {
    ! abs_or_rel:=  0: relative strength  1: absolut stength
    ! order     :=  magnet order (1: dipole, 2:quadrupole, ...)
    
    inout_B1     := table(HLLHCROTATIONS, slot.B1, inout);    // 0: single bore    else: double bore
    inout_B2     := table(HLLHCROTATIONS, slot.B2, inout);    // 0: single bore    else: double bore
    !inout     := table(HLLHCROTATIONS, typm, inout);    // 0: single bore    else: double bore
    
    print, text="NEW error routines used (master)";
    value, ver_hllhc_optics, typm, slot, inout_B1, inout_B2, abs_or_rel, order;

    if (inout_B1 == 0 && inout_B2 == 0) { 
        exec, Efcomp_Random_Multi_SingleBore(typm, slot, abs_or_rel, order); }
    else { 
        exec, Efcomp_Random_Multi_DoubleBore(typm, slot, abs_or_rel, order); 
    };
};


Efcomp_Random_Multi_SingleBore(typm, slot, abs_or_rel, order) : macro = {
    ! abs_or_rel:=  0: relative strength  1: absolut stength
    ! order     :=  magnet order (1: dipole, 2:quadrupole, ...)

    yrotangle := table(HLLHCROTATIONS, slot, yrota);    // rotation around vertical axis
    ! srotangle := table(HLLHCROTATIONS, slot, srota);    // rotation around beam axis
    inout     := table(HLLHCROTATIONS, slot, inout);    // 0: single bore        1: outer     2: inner
    if (yrotangle == 180) {yrotangle = 1;};
    
    print, text="NEW error routines used (Single Bore)";
    value, ver_hllhc_optics, typm, slot, iap, inout, yrotangle, abs_or_rel, order;
    
    exec new_magnetindividual(typm,inout);

    ! build aperture name from slotname
    if (abs_or_rel == 0) { exec, errorgenerate_rel(typm,$yrotangle,$order); };
    if (abs_or_rel == 1) { exec, errorgenerate_abs(typm,$yrotangle,$order,klRef_typm); };
};


Efcomp_Random_Multi_DoubleBore(typm, slot, abs_or_rel, order) : macro = {
     ! abs_or_rel:=  0: relative strength  1: absolut stength
     ! order     :=  magnet order (1: dipole, 2:quadrupole, ...)
!    if (use_average_errors_typm == 0) {
!        if (mylhcbeam == 1) { slot_new=slot.B1 };
!        if (mylhcbeam  > 1) { slot_new=slot.B2 };
!        yrotangle := table(HLLHCROTATIONS, slot_new, yrota);    // rotation around vertical axis
!        ! srotangle := table(HLLHCROTATIONS, slot_new, srota);    // rotation around beam axis
!        inout     := table(HLLHCROTATIONS, slot_new, inout);    // 0: single bore        1: outer     2: inner
!        if (yrotangle == 180) {yrotangle = 1;};
!
!        exec new_magnetindividual(typm,inout);
!    };
    if (use_average_errors_typm == 0) {
        yrotangle := table(HLLHCROTATIONS, slot.B1, yrota);    // rotation around vertical axis
        ! srotangle := table(HLLHCROTATIONS, slot.B1, srota);    // rotation around beam axis
        inout     := table(HLLHCROTATIONS, slot.B1, inout);    // 0: single bore        1: outer     2: inner
        if (yrotangle == 180) {yrotangle = 1;};

        exec new_magnetindividual(typm,inout);
        exec average_of_randoms(ssr_B1,ssr,ssr);
        
        
        yrotangle := table(HLLHCROTATIONS, slot.B2, yrota);    // rotation around vertical axis
        ! srotangle := table(HLLHCROTATIONS, slot.B2, srota);    // rotation around beam axis
        inout     := table(HLLHCROTATIONS, slot.B2, inout);    // 0: single bore        1: outer     2: inner
        if (yrotangle == 180) {yrotangle = 1;};

        exec new_magnetindividual(typm,inout);
        exec average_of_randoms(ssr_B2,ssr,ssr);
        
        
        exec average_of_randoms(ssr,ssr_B1,ssr_B2);
        if (mylhcbeam == 1) { exec average_of_randoms(ssr,ssr_B1,ssr_B1); };
        if (mylhcbeam  > 1) { exec average_of_randoms(ssr,ssr_B2,ssr_B2); };
    };
    if (use_average_errors_typm == 1) {
        yrotangle   := table(HLLHCROTATIONS, slot.B1, yrota);    // rotation around vertical axis
        ! srotangle   := table(HLLHCROTATIONS, slot.B1, srota);    // rotation around beam axis
        if (yrotangle == 180) {yrotangle = 1;};
        
        inout_B1  := table(HLLHCROTATIONS, slot.B1, inout);    // 0: single bore        1: outer     2: inner
        exec new_magnetindividual(typm,inout_B1);  exec average_of_randoms(ssr_B1,ssr,ssr);
        
        inout_B2  := table(HLLHCROTATIONS, slot.B2, inout);    // 0: single bore        1: outer     2: inner
        exec new_magnetindividual(typm,inout_B2);  exec average_of_randoms(ssr_B2,ssr,ssr);
        
        exec average_of_randoms(ssr,ssr_B1,ssr_B2);
    };
    
    print, text="NEW error routines used (Double Bore)";
    value, ver_hllhc_optics, typm, slot, iap, inout, yrotangle, abs_or_rel, order;
    
    if (abs_or_rel == 0) { exec, errorgenerate_rel(typm,$yrotangle,$order); };
    if (abs_or_rel == 1) { exec, errorgenerate_abs(typm,$yrotangle,$order,klRef_typm); };
};
